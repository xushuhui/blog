---
title: Redis非阻塞模式
published: 2020-09-11 19:01:42
tags: [Redis]
categories: ["Redis"]
top: 0
---
## 非阻塞模式

设置socket网络模型的非阻塞模式，需要三个关键函数socket()、listen()和accept()

在socket模型中，不同操作调用后会返回不同套接字类型。socket()方法返回主动套接字，然后调用listen()方法将主动套接字转化为监听套接字，监听客户端的连接请求，最后调用accept()方法接收到达的客户端连接，并返回已连接的套接字。


| 调用方法 | 返回套接字类型 | 非阻塞模式 |        效果         |
| :------: | :------------: | :--------: | :-----------------: |
| socket() |   主动套接字   |            |                     |
| listen() |   监听套接字   |   可设置   |   accept()非阻塞    |
| accept() |  已连接套接字  |   可设置   | send()/recv()非阻塞 |

## Redis套接字类型与非阻塞设置

针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是，你要注意的是，调用 accept() 时，已经存在监听套接字了。虽然 Redis 线程可以不用继续等待，但是总得有机制继续在监听套接字上等待后续连接请求，并在有请求时通知 Redis。

类似的，我们也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis。这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis 无法处理实际到达的连接请求或数据。

### 基于多路复用的高性能 I/O 模型

Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是我们经常听到的 select/epoll 机制。

在 Redis 只运行单线程的情况下，该机制允许内核中，同时存在多个监听套接字和已连接套接字。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。
下图就是基于多路复用的 Redis IO 模型。图中的多个 FD 就是刚才所说的多个套接字。Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。


## 总结

Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。
单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点。
